\documentclass[a4paper,12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{mathpazo}
\usepackage{wasysym}
\usepackage{graphicx}
\usepackage{tikz,pgfplots}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{natbib} 
\usepackage{geometry}
\usetikzlibrary{fit,shapes.misc,snakes}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=4cm,rmargin=4cm}

\newcommand{\ord}{\operatorname{ord}}

\graphicspath{ {../Project2/measurements/} }

\begin{document}

\title{I/O-algorithms\\Project 2}

\author{Lasse Espeholt - 20093223\\
Kasper Nielsen - 20091182\\}

\maketitle
\begin{figure}[h!]
\includegraphics[width=\textwidth]{"images/forside"}
\end{figure}

\vfill{}
\begin{description}
\item [{Implementation~code~and~test~results:}]~
\\
\texttt{\url{https://github.com/kasper0406/IO13/tree/master/Project2/}}
\end{description}
\pagebreak{}\tableofcontents{}\pagebreak{}

\section{Introduction}
\input{introduction.tex}

\section{Setup}
This section presents the test setup, how measurements were performed
and gives an overview of the files attached to this report.

\subsection{Test setup}
\input{test_setup.tex}

\subsection{File structure}
The following is a description of the different folders available at
\\
\texttt{\url{https://github.com/kasper0406/IO13/tree/master/Project2/}}
\begin{description}
\item[root] Contains the implementations of the different streams and
  the external heap.

% TODO:

\end{description}

\section{Implementation}
This section will present implementation details on how the heap has
been implemented, and why these choices were made. Also the details of
all the implemented streams are discussed.

We define the following:
\begin{itemize}
\item $V$ is the maximal number of elements in a node. Hence, a
  node is imperfect if it contains $< \left\lceil \frac{V}{2}
  \right\rceil$ elements.
\end{itemize}

\subsection{Heap}
In the paper the structure of the heap was represented using pointers,
such that every node stores pointers to its children and its
parent. Instead, we have chosen to embed the structure of the heap
inside an array, such that an array entry contains a reference to a
node in the heap. Then the index of the parent node and the indices of
the child node can be calculated using simple integer operations, and
the corresponding node can be found by looking up in the node array.

Using this representation, it is also very easy to swap the position
of two nodes, as the two entries in the array can simply be swapped
(this is required in the insert operation when the last node is
imperfect).

To store the elements of the heap, a big file have been allocated on
disk. This file is (virtually) divided into blocks of size $V$, such
that each block is associated with a node in the tree.

When elements are inserted into the heap, they file may become too
small. Hence when a new block is added, and the file does not have
enough space, the file is extended by $V$ elements. Growing the file
should be handled by the operating system using only constant IOs, and
hence there should be no problem in growing the file every time a new
node is added.


When inserting into the heap, the

 - Re-sizing of the heap file
 - How streams corresponds to blocks
   * How elements are stored inside a block

 - Merging of blocks (sifting): memory efficient / memory wasting
   * Caching of minimum element in node
   * Division of elements (wrong in paper)

\subsubsection{Verifying correctness}
 * Graphical dot representation
 * Consistency check function
 * Check that output is sorted when inserting and then extracting (external heap sorting)

\subsection{Streams}

To support the heap structure, the stream interface supported the following operations:

\begin{description}
\item[{\texttt{open}}] Opens the stream for read/write
\item[{\texttt{close}}] Closes the stream and deallocates buffers if applicable
\item[{\texttt{peek}}] Peeks at the current location
\item[{\texttt{read\_next}}] Reads at the current location and advances the location
\item[{\texttt{read\_prev}}] Reads at the current location and moves back
\item[{\texttt{write}}] Writes at the current location and advances the location
\item[{\texttt{backward\_write}}] Writes at the current location and moves back
\item[{\texttt{position}}] Return the current location
\item[{\texttt{seek}}] Changes the location
\end{description}

\texttt{read\_prev} and \texttt{backward\_write} were needed for the memory efficient sifting algorithm.

\subsubsection{Buffered stream}

The implementation of buffered stream were slightly more complex than the implementation in project 1 because of the extended stream interface with methods like \texttt{seek} and \texttt{read\_prev}.

% TODO: How the final buffered stream looked like. And how we choose those options.

\subsubsection{Memory mapped stream}

In project 1, the memory mapped stream mapped small blocks of the file when they were needed. This is not the most natural way to utilize memory mapped files. Instead, the memory mapped stream used in this projects maps the whole file once and remaps the file if the file size changes. In this way, the operating system is completely in charge of utilizing file caches in the best possible way.

% TODO: Test MMapStream vs. MMapFileStream.

\subsubsection{Cached stream}

To make it very fast to retrieve the maximum element of especially the root but also other nodes, a cached stream were implemented. It caches reads but propagates writes to the underlying stream.

The caching is very important for the analysis of the algorithm. If no cache where used in the root node, every extract max operation would result in an I/O. Hence, the algorithm would have the complexity $O(N\log \frac{N}{B})$ instead of $O(\frac{N}{B}\log \frac{N}{B})$. Furthermore, in the refill operation all the children's maximum element is look at which also would result in an I/O.

\subsubsection{Other streams}

A stream using the POSIX methods \texttt{read} and \texttt{write} and a stream using \texttt{fread} and \texttt{fwrite} were also implemented. The stream interface almost mapped one-to-one and are therefore not explained in more detail.

\section{Benchmarks}

\subsection{Sift algorithm variations}

\subsection{Streams}

% TODO: Find konfigurationer

\subsection{Cached stream}

\subsection{Heap}

% TODO: Med de bedste stream konfigurationer + cached

\subsection{Comparison}

\section{Conclusion}
\input{conclusion.tex}

\clearpage{}\bibliographystyle{plain}
\addcontentsline{toc}{section}{\refname}\bibliography{ref}

\end{document}
