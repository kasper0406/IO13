\documentclass[a4paper,12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{mathpazo}
\usepackage{wasysym}
\usepackage{graphicx}
\usepackage{tikz,pgfplots}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{natbib} 
\usepackage{geometry}
\usetikzlibrary{fit,shapes.misc,snakes}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=4cm,rmargin=4cm}

\newcommand{\ord}{\operatorname{ord}}

\graphicspath{ {../Project2/measurements/} }

\begin{document}

\title{I/O-algorithms\\Project 2}

\author{Lasse Espeholt - 20093223\\
Kasper Nielsen - 20091182\\}

\maketitle
\begin{figure}[h!]
\includegraphics[width=\textwidth]{"images/forside"}
\end{figure}

\vfill{}
\begin{description}
\item [{Implementation~code~and~test~results:}]~
\\
\texttt{\url{https://github.com/kasper0406/IO13/tree/master/Project2/}}
\end{description}
\pagebreak{}\tableofcontents{}\pagebreak{}

\section{Introduction}
\input{introduction.tex}

\section{Setup}
This section presents the test setup, how measurements were performed
and gives an overview of the files attached to this report.

\subsection{Test setup}
\input{test_setup.tex}

\subsection{File structure}
The following is a description of the different folders available at
\\
\texttt{\url{https://github.com/kasper0406/IO13/tree/master/Project2/}}
\begin{description}
\item[root] Contains the implementations of the different streams and
  the external mergesort.

\item[measurements/] Contains the raw measurements used for the plots in the
  report. The plots themselves are also included in a pdf-format.
\end{description}

\subsubsection{Code structure}
The code has the following source files:
\begin{description}
\item[main.cpp] Driver code for calling test code.
\item[test.h] Test framework for testing streams and sorting with
  different parameters.
\item[utils.h] Responsible for generating large files for testing.
\item[CMakeLists.txt] CMake file for the project specifying
  compilation options.

\item[rw\_stream.h] Shared code for streams using \texttt{write} and
  \texttt{read} system calls. The unbuffered streams are implemented
  in:
  \begin{itemize}
  \item read\_input\_stream.h
  \item write\_output\_stream.h
  \end{itemize}
  The buffered streams are implemented in:
  \begin{itemize}
  \item buffered\_input\_stream.h
  \item buffered\_output\_stream.h
  \end{itemize}

\item[f\_stream.h] Shared code for streams using \texttt{fwrite} and
  \texttt{fread} functions from the C standard library. Specific
  stream implementations are:
  \begin{itemize}
  \item fread\_input\_stream.h
  \item fwrite\_output\_stream.h
  \end{itemize}

\item[mmap\_stream.h] Shared code for streams using memory mapping of
  files. Specific stream implementations are:
  \begin{itemize}
  \item mmap\_input\_stream.h
  \item mmap\_output\_stream.h
  \end{itemize}
\end{description}

\section{Implementation}
This section will present implementation details on how the heap has
been implemented, and why these choices were made. Also the details of
all the implemented streams are discussed.

We define the following:
\begin{itemize}
\item $V$ is the maximal number of elements in a node. Hence, a
  node is imperfect if it contains $< \left\lceil \frac{V}{2}
  \right\rceil$ elements.
\end{itemize}

\subsection{Heap}
In the paper the structure of the heap was represented using pointers,
such that every node stores pointers to its children and its
parent. Instead, we have chosen to embed the structure of the heap
inside an array, such that an array entry contains a reference to a
node in the heap. Then the index of the parent node and the indices of
the child node can be calculated using simple integer operations, and
the corresponding node can be found by looking up in the node array.

Using this representation, it is also very easy to swap the position
of two nodes, as the two entries in the array can simply be swapped
(this is required in the insert operation when the last node is
imperfect).

To store the elements of the heap, a big file have been allocated on
disk. This file is (virtually) divided into blocks of size $V$, such
that each block is associated with a node in the tree.

When elements are inserted into the heap, they file may become too
small. Hence when a new block is added, and the file does not have
enough space, the file is extended by $V$ elements. Growing the file
should be handled by the operating system using only constant IOs, and
hence there should be no problem in growing the file every time a new
node is added.


When inserting into the heap, the

 - Re-sizing of the heap file
 - How streams corresponds to blocks
   * How elements are stored inside a block

 - Merging of blocks (sifting): memory efficient / memory wasting
   * Caching of minimum element in node
   * Division of elements (wrong in paper)

\subsubsection{Verifying correctness}
 * Graphical dot representation
 * Consistency check function
 * Check that output is sorted when inserting and then extracting (external heap sorting)

\subsection{Streams}

\subsubsection{SysStream}

\subsubsection{FStream}

\section{Benchmarks}

\subsection{Streams}

% TODO: Find konfigurationer

\subsection{Cached stream}

\subsection{Heap}

% TODO: Med de bedste stream konfigurationer + cached

\subsection{Comparison}

\section{Conclusion}
\input{conclusion.tex}

\clearpage{}\bibliographystyle{plain}
\addcontentsline{toc}{section}{\refname}\bibliography{ref}

\end{document}
